##问题描述
最近在实现一个定时重启tomcat的工作，脚本写好之后执行没有问题，但是放到crontab中却一直无法执行。具体表现就是重启tomcat的过程中并没有将旧的tomcat进程删除就起了新的tomcat进程，由此引起进程过多的问题。

##解决思路
脚本很简单，直接执行没有问题，所以不是脚本内容的问题。很明确问题来自于crontab执行脚本过程。脚本执行可能产生问题的可以先向权限、路径、环境变量这三个方向排查。

- 权限：当前crontab用户可能没有权限执行脚本的一些需要较高权限的语句。解决些类问题只需将脚本放在拥有较要权限的用户之下就可以了。
- 路径：对于shell在crontab中无法执行的问题，权限不足的问题相对来说发现的比较容易，但是此类问题占的比例未不多。路径和环境变量占有很大的比重。路径主要指的是crontab配置任务时指定的脚本路径，最好使用绝对路径。
- 环境变量：写好脚本直接执行其实是在交互式的shell中执行，交互式shell的环境变量与crontab中的不同就是产生问题的根源，需要在脚本的开头加入环境变量的设置。

##解决方案
1. 将脚本任务置于与之权限相适应的用户的crontab之下。
2. 修改原有crontab中的任务设置，脚本的路径使用绝对路径，注意一些转义字符的使用。(PS:路径写法中有很多细节的部分，后面有时间的话再补充完善，目前就先作个引子)   
以重启tomcat任务为例：  
```
0 1 * * * /root/restart.sh
```  
改后为  
```
0 1 * * * /root/&&bash restart.sh
```
3. 设置脚本的环境变量，在原有脚本的开头加入  
PATH=/bin:/usr/sbin:/sbin:/usr/local/bin:/usr/home/x/bin ①  
①是echo $PATH的结果  
当然要是一些特殊的环境变量，也需要在脚本的开头一并写明

##思考
关于shell环境变量的问题  
什么是shell环境变量？shell作为内核的一个外壳，通过它我们可以直接把命令行递交给内核，当然内核也会处理后返回。shell有一个父进程，我们执行的任何shell程序，都是由此产生的一个sub-shell（子shell），所谓环境变量其实就是那些会传给子进程的变量。

最后的最后，如果分析得深入一点还涉及到linux启动过程与shell的关系，伪终端与shell的关系。限于本人对linux理解有限就在此瞎BB了，有兴趣的话可以查看《Linux与unix shell编程指南》和《shell十三问》
